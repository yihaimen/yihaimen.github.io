---
title: "从 0 到 1 TDD实战"
date: 2020-06-13T14:25:01+08:00
author: "易海门"
authorLink: "https://yihaimen.github.io"
description: "将学会如何及时地编写测试，并用这些测试来影响代码的设计"
featuredImage: ""
featuredImagePreview: ""
categories: ["TestDrivingJSApp"]
tags: ["JavaScript", "TDD", "Jest"]
license: "Creative Commons Attribution 4.0 International license"
draft: true
---
## 引言
上边文章我说了自己不会真正的写UnitTest，虽然当下就查了些概念性的资料，但“道理（高内聚，低耦合，模块化，好设计，已修改，好维护）都懂，依然过不好这一生”的感受令我难受，于是我勇敢地迈出了第一步。

## 故事
我现在所做的事情就是在老系统中加新的需求，改老的功能，且需要加上测试。亲身体验就是代码完成后真的很难编写出有效的测试了，这个时候更像是代码驱动测试，对代码的设计没有任何帮助，最多就是完成了所谓的测试覆盖率。

尽早编写测试，可以让我们从代码使用者的角度思考问题，进而设计代码。可能也会和我一样，刚开始不知道从哪里入手，这确实是一个很有挑战性的事情，毕竟大部分程序员是没有写过测试或真正会写测试的。此文将从如何开始编写测试，到测试驱动代码设计。在这之前，默认你会使用JavaScript和Jest，当然测试框架也可以使用你自己熟悉的，比如Mocha等。

## 实践
我们将从一个小的栗子（回文）着手热身，学习一下编写测试的基本原理。

### 第一步 创建测试套件和金丝雀测试 
测试套件：一组相关测试的集合，这组测试验证一个函数或者一组密切相关的函数的行为。
金丝雀测试：最简单的测试，为了验证开发环境是否正确安装。

通过查看Jest的文档，可以知道测试套件的关键字是describe，测试用例的关键字是it，它们都有两个参数即一个名称和一个函数，需要注意的是测试套件的名称和测试用例的名称都要简洁明了，且测试用例的名称要清楚表达测试目的和期望得到的结果，因为单测只是为了验证代码的正确行为，而我们的测试名称，描述、表达并记录了代码的行为，或者说原始需求。最后，为了让测试贴合应用，我们需要与团队中的其他成员沟通，搞清楚真正的需求是什么，这样才能编写出行为正确的代码。

```javascript
    // plaindrome.test.js
    describe('palindrome test', () => {
        it('should pass this canary test', () => {
            expect(true).toBe(true);
        });
    });
```

![FeedBack]()
如上图，则说明我们的环境安装成功，下班就开始编写回文项目了。

### 第二步 开始编写单元测试
在编写测试的时候，我们是有模式可以遵循的：
1. 3As模式：Arrange-Act-Assert
2. GWT表达式：Given-When-Then
不管是哪一种模式，其实都是这三步：准备数据-执行函数-断言结果。所以在每个单测中也是有这三部分代码的，为了让代码看着舒服，不同的部分之间用空行隔开，另外每个单测里边的代码也需要保持简短，比如能用一行代码解决的事，也就不需要这个三段论了；相反要是一个单测代码冗长复杂，它可能表达出了两种意思：一是测试的代码写的不好，二是待测函数的设计不行。

有的同学就会想，模式我是知道了，可具体需要写哪些类型的测试来驱动开发，完善代码设计呢？有以下三种：
1. 正向测试
2. 反向测试
3. 异常测试


首先编写第一个测试用例：
```javascript
    // plaindrome.test.js
    it('should return true for argument mom', () => {
        expect(isPalindrome('mom')).toBe(true);
    });
```

!(Issue)[]
我们发现这个单测没有通过，看下Jest给我们反馈的信息告诉我们 isPalindrome 这个函数我们还没有实现或者还没有导入到测试文件中来，接下来我们将实现它并导入到测试文件中。
```javascript
    // plaindrome.js
    export const isPalindrome = () => {
        return true;
    } 
```

!(Okay)[]
现在我们看到我们的单测是通过了，那我们开始验证另外一个数据。
```javascript
    it('should return false for argument momu', () => {
        expect(isPalindrome('momu')).toBe(false);
    });
```

!(Refactor)[]
我们发现报错了，根据反馈说我们期望的结果是false，但是给我们返回的是true，这说明我们代码实现有问题了，此时就需要我们去重构。

```javascript
    export const isPalindrome = (word) => {
        return word.split('').reverse().join('') === word;
    } 
```
!(Okay)[]

总结一下上边编写一个单测到程序通过的过程，它是一条反馈环： Red - Green - Refactor。首先我们会编写一个失败的测试，设计好被测函数的名称和传参；然后就需要根据Jest给的反馈找到失败的原因，编写最少的代码或回退代码让单测通过；最后通过重构让代码更加完善。关于在这个反馈环中每个环节我们到底该做什么，请移步：xxx
我们之前是可能是这样做的：
1. 在声明测试方法后，便开始写实现代码；
2. 写完“所有”的测试代码才开始写实现；（这种估计很少，毕竟都不知道怎么写测试吧）
3. 从不重构；

当然上边的两个单测并不能完整的驱动代码的完成，初始的单测更像一个引导，有助于形成函数的接口，我们需要添加额外的单测用来驱动代码的完成，实现具体的需求。


## 参考
* Jest官网
* 《JavaScript测试驱动开发》


