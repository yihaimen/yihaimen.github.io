[{"categories":["JavaScript"],"content":"0x00 引言 大家好，我是以卖码为生的海门。今天想和大家探讨一下普通函数与箭头函数有什么区别？ 大家也许在面试的时候被问及过这个问题，而我是在一次和同事的交谈中被问及的。我当时的回答是：普通函数可以在它定义之前的位置使用它，即与位置无关，而箭头函数不行，且箭头函数没有 this。这么回答很显然是说服不了任何人的。 ","date":"31310-34-310","objectID":"/2020/07/%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/:1:0","tags":["JavaScript"],"title":"普通函数与箭头函数有什么区别","uri":"/2020/07/%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"},{"categories":["JavaScript"],"content":"0x01 书写形式 简单罗列几种使用过程中的书写形式。主要介绍定义方式，有参无参，返回一条语句或一个对象的情况。相信大家很容易区分书写方式的异同，在实际开发过程中或多或少写这么写过，书写形式方面的区别就不做过多的赘述了，一句话总结就是箭头函数更加简洁明了。 箭头函数 const doSomething = () =\u003e { return a + b; } const doSomething1 = (a, b) =\u003e a + b; const doSomething2 = c =\u003e ({name: c}); 普通函数 const doSomething = function() { return a + b; } const doSomething1 = function(a, b) { return a + b; } const doSomething2 = function(c) { return {name: c}; } ","date":"31310-34-310","objectID":"/2020/07/%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/:2:0","tags":["JavaScript"],"title":"普通函数与箭头函数有什么区别","uri":"/2020/07/%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"},{"categories":["JavaScript"],"content":"0x02 关于 this 想必大家都有被 this 指针搞晕的情况，我最近还遇到了。 ","date":"31310-34-310","objectID":"/2020/07/%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/:3:0","tags":["JavaScript"],"title":"普通函数与箭头函数有什么区别","uri":"/2020/07/%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"},{"categories":["TestDrivingJSApp"],"content":"通过学习到达真的会写 UnitTest 的目的","date":"8080-43-80","objectID":"/2020/07/%E7%8E%A9%E8%BD%ACunittest%E4%B9%8B%E5%B7%A7%E5%A6%99%E5%A4%84%E7%90%86%E4%BE%9D%E8%B5%96/","tags":["JavaScript","TDD","UnitTest"],"title":"玩转UnitTest之巧妙处理依赖","uri":"/2020/07/%E7%8E%A9%E8%BD%ACunittest%E4%B9%8B%E5%B7%A7%E5%A6%99%E5%A4%84%E7%90%86%E4%BE%9D%E8%B5%96/"},{"categories":["TestDrivingJSApp"],"content":"0x00 引言 大家好，我是以卖码为生的海门。今天想和大家探讨一下如何巧妙处理依赖，玩转 UnitTest。 我们平时使用的网络请求库 Axios 等，这些对我们的项目来说都是依赖，可以说依赖无处不在，它的存在更容易发起网络请求，格式化时间等，但同样也带来了问题 - 很难为代码编写单元测试。 ","date":"8080-43-80","objectID":"/2020/07/%E7%8E%A9%E8%BD%ACunittest%E4%B9%8B%E5%B7%A7%E5%A6%99%E5%A4%84%E7%90%86%E4%BE%9D%E8%B5%96/:1:0","tags":["JavaScript","TDD","UnitTest"],"title":"玩转UnitTest之巧妙处理依赖","uri":"/2020/07/%E7%8E%A9%E8%BD%ACunittest%E4%B9%8B%E5%B7%A7%E5%A6%99%E5%A4%84%E7%90%86%E4%BE%9D%E8%B5%96/"},{"categories":["TestDrivingJSApp"],"content":"0x01 让我们开始吧 在正式进入主题之前，我会先告诉你，为了让我们的单测达到 F.A.I.R 原则的标准，我们需要解决的问题是： 功能代码使用良好的设计，对依赖进行解耦，尽可能去除依赖； 实在去除不了的依赖，如内部依赖，通过依赖注入构建松耦合的代码。测试代码使用一些技术进行替代，我们称这些技术叫测试替身 - 包括 Dummy、Fake、Stub、Mock和Spy。 需求：通过getCurrentPosition函数获取经纬度，定义一个供百度地图使用的 URL ，将该 URL 赋值给 window.location 。如果获取位置失败，则设置一条错误消息。 通过简单的需求分析和任务拆分，都会认为这个需求很简单。可是我们如何为它写自动化测试呢？没有写过UT的我，刚开始也是很懵的。跟我刚开始被要求为功能写单元测试的时候一样懵，完全不知道从那入手~我在搜索引擎中找到了一个解决方法，即借助。 ","date":"8080-43-80","objectID":"/2020/07/%E7%8E%A9%E8%BD%ACunittest%E4%B9%8B%E5%B7%A7%E5%A6%99%E5%A4%84%E7%90%86%E4%BE%9D%E8%B5%96/:2:0","tags":["JavaScript","TDD","UnitTest"],"title":"玩转UnitTest之巧妙处理依赖","uri":"/2020/07/%E7%8E%A9%E8%BD%ACunittest%E4%B9%8B%E5%B7%A7%E5%A6%99%E5%A4%84%E7%90%86%E4%BE%9D%E8%B5%96/"},{"categories":["TestDrivingJSApp"],"content":"1、借助Spike技术编写原型代码 ","date":"8080-43-80","objectID":"/2020/07/%E7%8E%A9%E8%BD%ACunittest%E4%B9%8B%E5%B7%A7%E5%A6%99%E5%A4%84%E7%90%86%E4%BE%9D%E8%B5%96/:2:1","tags":["JavaScript","TDD","UnitTest"],"title":"玩转UnitTest之巧妙处理依赖","uri":"/2020/07/%E7%8E%A9%E8%BD%ACunittest%E4%B9%8B%E5%B7%A7%E5%A6%99%E5%A4%84%E7%90%86%E4%BE%9D%E8%B5%96/"},{"categories":["TestDrivingJSApp"],"content":"2、从中获得一些信息 getCurrentPosition是一个异步函数，包含成功和失败两个回调函数 获取到经纬度时，拼接成一条URL 未获取到经纬度时，设置错误信息 将 url 赋值给 location，此时浏览器会发生重定向 通过对原型代码的观察，发现其可测试性很差，而我们知道代码是否具有可测试性是个设计问题。所以，我们将解决第一个问题，即尽可能去除被测代码中的依赖。抽取函数，并将最少的数据作为参数传给它，对代码进行模块化设计。 ","date":"8080-43-80","objectID":"/2020/07/%E7%8E%A9%E8%BD%ACunittest%E4%B9%8B%E5%B7%A7%E5%A6%99%E5%A4%84%E7%90%86%E4%BE%9D%E8%B5%96/:2:2","tags":["JavaScript","TDD","UnitTest"],"title":"玩转UnitTest之巧妙处理依赖","uri":"/2020/07/%E7%8E%A9%E8%BD%ACunittest%E4%B9%8B%E5%B7%A7%E5%A6%99%E5%A4%84%E7%90%86%E4%BE%9D%E8%B5%96/"},{"categories":["TestDrivingJSApp"],"content":"3、模块化设计 有没有发现自己很多时候写的代码其实是原型代码，并没有设计可言！很多时候不写测试，根本发现不了这些问题，也不会对代码的设计有任何想法，更不用说什么设计模式地使用了。 接下来我们将 spike 阶段的原型代码进行拆分，是每个小功能都是一个小函数，每个小函数具有单一职责和最少依赖的特征。 下边需要做的就是为每一个函数编写自动化测试，以验证它们的行为。 依赖在整个问题中占据了很重要的作用，编写自动化测试的第一步就是确定一个或多个不具有内部依赖的函数，这些函数应该成为自动化测试的起点。 createUrl 就是我们要找函数，因为它没有任何其他依赖的代码测起来相对容易，只需要接收到正确的位置信息，然后创建一条符合预期的URL 就可以了。 接下来根据测试列表中的用例为其编写同步测试、反向测试、异常测试，之前介绍过方法就不再赘述了。 ","date":"8080-43-80","objectID":"/2020/07/%E7%8E%A9%E8%BD%ACunittest%E4%B9%8B%E5%B7%A7%E5%A6%99%E5%A4%84%E7%90%86%E4%BE%9D%E8%B5%96/:2:3","tags":["JavaScript","TDD","UnitTest"],"title":"玩转UnitTest之巧妙处理依赖","uri":"/2020/07/%E7%8E%A9%E8%BD%ACunittest%E4%B9%8B%E5%B7%A7%E5%A6%99%E5%A4%84%E7%90%86%E4%BE%9D%E8%B5%96/"},{"categories":["TestDrivingJSApp"],"content":"4、使用测试替身 接下来就是有依赖需要处理的函数，我们需要使用替身来解决第二个问题。 什么是替身？ 代替真正依赖的对象，从而让自动化测试可以进行。就好比电影中的替身演员，当主角完不成不了某专业且高难度的动作时，此时替身演员就会上场，而替身演员的目的是为了让电影继续拍下去，比如主角没有找替身，要是残了的话，这部电影岂不是拍不下去了？！ 如果还不了解这五种类型的测试替身，可以先花点时间看看。 我们将为依赖 window 对象的 location 属性的 setLocation 函数编写测试。首先试想一下，我们在没有单元测试的时候，是不是这样调试的？在这个方法打一个断点，看url是不是创建成功，然后下一步看浏览器是不是跳转了。事实上，这样是很费时费力的，目前我们需要解决的问题是： 我们给一个window对象的location属性设置值之后，验证其正确性，而不是浏览器做出来什么响应，并且是能使用单元测试不要使用UI测试（测试金字塔）。 怎么解决？ 为window对象注入一个stub。 在正式开始前，我们还需要了解什么是依赖注入： 依赖注入是用测试替身代替依赖的一种流行、通用的技术。也就是说依赖是作为一个参数传递给函数的，而不是直接在函数中引用的。 ","date":"8080-43-80","objectID":"/2020/07/%E7%8E%A9%E8%BD%ACunittest%E4%B9%8B%E5%B7%A7%E5%A6%99%E5%A4%84%E7%90%86%E4%BE%9D%E8%B5%96/:2:4","tags":["JavaScript","TDD","UnitTest"],"title":"玩转UnitTest之巧妙处理依赖","uri":"/2020/07/%E7%8E%A9%E8%BD%ACunittest%E4%B9%8B%E5%B7%A7%E5%A6%99%E5%A4%84%E7%90%86%E4%BE%9D%E8%B5%96/"},{"categories":["TestDrivingJSApp"],"content":"5、交互测试 什么是交互测试？ 在了解交互测试之前，我们先回顾一下之前为同步和异步函数编写的测试，给定特定的参数，它们的预期值始终是不变的，我们把这些测试称为经验测试 ~ 结果是确定的、可预测的，且很容易断定的。 但当我们涉及依赖时，其结果是很难预测的。在编写测试时，需要将注意力放在函数的行为，而不是函数依赖对象是否正确。也就是说我们不需要管这个对象是真是假，只需要检查代码能够以正确的方式与依赖对象进行交互就好了。当函数的依赖成功执行或执行失败时，函数是否进行了正确的处理。我们称这为交互测试 ~ 代码中有很复杂的依赖关系，而且依赖让代码不确定、难以预测、脆弱或耗时。 接下来将使用交互测试为locate函数编写测试用例了。在locate函数中，我们依赖一个异步函数getCurrentPosition去获取当前位置，需要注意的是我们无法确定“当前”位置的准确度，不能依赖这个结果，故根据上边的总结得出我们就没有必要采取经验测试了。 最终，我们需要使用交互测试，专注验证locate函数与getCurrentPosition函数的交互行为，而不是验证getCurrentPosition函数最终返回了正确的位置。因为是为了验证locate函数是否调用了它依赖的函数，所以使用测试替身mock来代替getCurrentPosition函数。但为啥没有使用依赖注入呢？这是因为navigator的属性比location的属性更容易模拟。我们首先复制了getCurrentPosition函数，然后给了它一个模拟的函数，最后又将其还原。这个方法的好处就是让测试变得快速，且可预测。并且我们不用处理是否允许浏览器获取用户位置的问题。 在模拟函数中检查传入的两个参数是否是对onSuccess和onError函数的引用。会存在三种情况： 1、调用了getCurrentPosition函数，并传递了预期的回调函数，测试通过； 2、调用了getCurrentPosition函数，没有传递了预期的回调函数，测试失败； 3、没有调用getCurrentPosition函数，测试失败。 ","date":"8080-43-80","objectID":"/2020/07/%E7%8E%A9%E8%BD%ACunittest%E4%B9%8B%E5%B7%A7%E5%A6%99%E5%A4%84%E7%90%86%E4%BE%9D%E8%B5%96/:2:5","tags":["JavaScript","TDD","UnitTest"],"title":"玩转UnitTest之巧妙处理依赖","uri":"/2020/07/%E7%8E%A9%E8%BD%ACunittest%E4%B9%8B%E5%B7%A7%E5%A6%99%E5%A4%84%E7%90%86%E4%BE%9D%E8%B5%96/"},{"categories":["TestDrivingJSApp"],"content":"0x02 总结 通过我自己的学习与实践，得知道理都懂，还是需要多练多看，不然还是不知道如何下手。在真正学会测试驱动代码设计之后呢，就需要学会如何识别‘坏味道’即重构手法，这也是需要平时的积累。最后就是去学习能提高效率的指法和快捷键的使用。 最后，接下来根据自己的计划，需要学习数据结构了，同时也需要进一步去实践单元测试，之后至少会出一篇 Node.js 的单元测试策略和一篇 React 的单元测试策略的文章。 ","date":"8080-43-80","objectID":"/2020/07/%E7%8E%A9%E8%BD%ACunittest%E4%B9%8B%E5%B7%A7%E5%A6%99%E5%A4%84%E7%90%86%E4%BE%9D%E8%B5%96/:3:0","tags":["JavaScript","TDD","UnitTest"],"title":"玩转UnitTest之巧妙处理依赖","uri":"/2020/07/%E7%8E%A9%E8%BD%ACunittest%E4%B9%8B%E5%B7%A7%E5%A6%99%E5%A4%84%E7%90%86%E4%BE%9D%E8%B5%96/"},{"categories":["TestDrivingJSApp"],"content":"0x03 参考 《JavaScript测试驱动开发》 Jest 官网 代码仓库：https://github.com/yihaimen/JestJsApp B 站链接：https://space.bilibili.com/383362014 博客地址：https://yihaimen.github.io/ ","date":"8080-43-80","objectID":"/2020/07/%E7%8E%A9%E8%BD%ACunittest%E4%B9%8B%E5%B7%A7%E5%A6%99%E5%A4%84%E7%90%86%E4%BE%9D%E8%B5%96/:4:0","tags":["JavaScript","TDD","UnitTest"],"title":"玩转UnitTest之巧妙处理依赖","uri":"/2020/07/%E7%8E%A9%E8%BD%ACunittest%E4%B9%8B%E5%B7%A7%E5%A6%99%E5%A4%84%E7%90%86%E4%BE%9D%E8%B5%96/"},{"categories":["TestDrivingJSApp"],"content":"0x00 引言 大家好，我是以卖码为生的海门。今天想和大家探讨一下如何为异步函数编写单元测试。 在实际的编码过程中，会遇到很多的异步函数，比如网络请求，文件读取等。它与同步函数的不同点在于它的结果是由回调函数或 Promise 对象返回的，也就是说在调用异步函数之后，不会像同步函数那样，被调用时挂起，直到操作完成就会得到结果。 ","date":"29290-44-290","objectID":"/2020/06/%E4%B8%BA%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95/:1:0","tags":["JavaScript","TDD","Jest"],"title":"如何为异步函数写测试?","uri":"/2020/06/%E4%B8%BA%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95/"},{"categories":["TestDrivingJSApp"],"content":"0x01 让我们开始吧 为了简单起见，这次的需求是：读取某一文件，并返回该文件的行数。 开始前，我会告诉我们需要解决的一个问题： 由于异步函数的结果不会立刻返回，所以在测试中需要有一个东西来证明回调函数或 Promise 对象返回了结果； 假设你已经会为同步函数编写测试了【如果不会请先花几分钟看这篇 】，然后一口气就写了如下的代码： // files.js import fs from 'fs'; export const linesCount = (fileName, onSuccess, onError) =\u003e { const processFile = (err, data) =\u003e { if (err) { onError('unable to open file ' + fileName); } else { onSuccess(data.toString().split('\\n').length); } }; fs.readFile(fileName, processFile); }; // files.test.js import { linesCount, linesCountP } from '../src/files'; describe('test server side callback', () =\u003e { it('should return correct lines count for a valid file', () =\u003e { const onSuccess = (data) =\u003e { try { expect(data).toBe(-100); } catch (error) { // nothing } }; linesCount('src/files.js', onSuccess); }); }); 上边的单测尽然通过了，可我设置的是 -100 行，没有比单测有误更糟的情况了。出现该问题就是因为单测不知道这个回调断言什么时候操作完成，即没有等到回调中的断言完成就结束了，所以我们来解决这个问题，加一个标识来验证回调操作完成。 // files.test.js import { linesCount, linesCountP } from '../src/files'; describe('test server side callback', () =\u003e { it('should return correct lines count for a valid file', (done) =\u003e { const onSuccess = (data) =\u003e { try { expect(data).toBe(-100); } catch (error) { // nothing } }; linesCount('src/files.js', onSuccess); }); }); 通过查阅 Jest 的文档，了解到 done 就是那个处理回调的标识，但此时我们去执行，会看到一个异步回调超时的错误（默认超时是5秒）。在固定的超时时间范围内，单测还是不知道回调中的断言什么时候完成的问题，所以我们需要将这个标识放到断言语句的后边。 // files.test.js import { linesCount, linesCountP } from '../src/files'; describe('test server side callback', () =\u003e { it('should return correct lines count for a valid file', (done) =\u003e { const onSuccess = (data) =\u003e { try { expect(data).toBe(-100); done(); } catch (error) { done(error); } }; linesCount('src/files.js', onSuccess); }); }); 这个时候你会看到 Expected: -100，Received: 25，到这儿就把 -100 改为 25 就结束了，但单测还没有写完，目前仅仅是做了一个正向测试。接下来就是编写反向测试和异步测试，基本方法与 4 年后，我再次入门 TDD 一样，只不过是需要为回调函数和断言语句后添加一个标识。 ","date":"29290-44-290","objectID":"/2020/06/%E4%B8%BA%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95/:2:0","tags":["JavaScript","TDD","Jest"],"title":"如何为异步函数写测试?","uri":"/2020/06/%E4%B8%BA%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95/"},{"categories":["TestDrivingJSApp"],"content":"0x02 测试Promise对象 上边描述了如何为回调函数编写测试，目的是为了简单阐述如何测试异步函数。因为大家都知道回调地狱的问题，所以出现了 Promise 这一异步解决方案，下来就介绍如何测试 Promise 对象。 有 4 种方式，第 3 和 第 4 种是常用方式，这里只介绍第 4 种书写方式，当然4 种方式没有优劣之分，只有哪些对自己的测试更简单： 1、使用 done 和 Promise 组合 2、返回 Promise 3、使用 async await 4、使用 async await 和 Promise 组合 此处我的浏览器是支持 AsyncFunction 特性的，如果不支持需要选用其他方式进行测试。我们只需要在单测函数的第二个参数加上 async 关键字，并在断言语句前加上 await 关键字，还使用了 Jest 提供的 resolves 和 rejects 匹配器简化测试语句。最后，异步测试依然遵循 3As 模式。 it('should return correct lines count for valid file - with promise and async', async () =\u003e { await expect(linesCountP('src/files.js')).resolves.toBe(25); }); it('should report error for an invalid file name - with promise and async', async () =\u003e { await expect(linesCountP('src/async/files.js')).rejects.toMatch('unable to open file src/async/files.js'); }); ","date":"29290-44-290","objectID":"/2020/06/%E4%B8%BA%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95/:3:0","tags":["JavaScript","TDD","Jest"],"title":"如何为异步函数写测试?","uri":"/2020/06/%E4%B8%BA%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95/"},{"categories":["TestDrivingJSApp"],"content":"0x03 总结 如果学会了为同步函数写测试的方法论，对异步函数编写测试会变得很简单。但我们依然需要面临一个现实问题 ~ 依赖，它的存在会让单测很难进行自动化，故下一次将与大家探讨如何进行重构且正确地处理依赖。 ","date":"29290-44-290","objectID":"/2020/06/%E4%B8%BA%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95/:4:0","tags":["JavaScript","TDD","Jest"],"title":"如何为异步函数写测试?","uri":"/2020/06/%E4%B8%BA%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95/"},{"categories":["TestDrivingJSApp"],"content":"0x04 参考 《JavaScript测试驱动开发》 Jest 官网 代码仓库：https://github.com/yihaimen/JestJsApp B 站链接：https://space.bilibili.com/383362014 博客地址：https://yihaimen.github.io/ ","date":"29290-44-290","objectID":"/2020/06/%E4%B8%BA%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95/:5:0","tags":["JavaScript","TDD","Jest"],"title":"如何为异步函数写测试?","uri":"/2020/06/%E4%B8%BA%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95/"},{"categories":["TestDrivingJSApp"],"content":"将学会如何及时地编写测试，并用这些测试来影响代码的设计","date":"13130-01-130","objectID":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/","tags":["JavaScript","TDD","Jest"],"title":"4 年后，我再次入门 TDD","uri":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/"},{"categories":["TestDrivingJSApp"],"content":"0x01 引言 大家好，我是以卖码为生的海门。今天想和大家探讨一下应该从哪里着手 TDD，以及要进行哪些类型的测试。本文及以后的文章都将使用 Jest 作为我们的测试工具。 刚毕业时，进了一家小微企业，这时不要求为代码写单测，我也不知道 TDD 的存在。直到进入第二家公司遇到了中仁并认识了亦乐，我们一起运营 freeCodecamp 社区，才有幸参加了一次由中仁发起的 TDD 工作坊，这是我第一次认识它，但并不会使用。我的第一次入门应该算是参加了熊节老师的训练营，可课程结束后，我学会了盲打，识别部分坏味道和重构手法，使用大部分快捷键，但我依然觉得自己不知如何去写 Unit Test，这是我再次学习和入门的原因。 ","date":"13130-01-130","objectID":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/:1:0","tags":["JavaScript","TDD","Jest"],"title":"4 年后，我再次入门 TDD","uri":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/"},{"categories":["TestDrivingJSApp"],"content":"0x02 让我们开始吧 第一步，我不会告诉你怎么安装开发环境，我只会告诉你怎么验证你的环境是否安装正确。 金丝雀测试，是最简单的测试，它的作用就是验证开发环境是否安装正确，确保正确开始。它存在的意义因此受到了质疑，但我认为保留它是有必要的。比如当我们换了新的工具或环境，它可以帮助我们快速的验证环境的正确性。 ","date":"13130-01-130","objectID":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/:2:0","tags":["JavaScript","TDD","Jest"],"title":"4 年后，我再次入门 TDD","uri":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/"},{"categories":["TestDrivingJSApp"],"content":"0x03 举个栗子：回文项目 在正式编码前，我会告诉你，入门 TDD 我们需要编写三种类型的测试： 正向测试：当前置条件满足时，验证代码的结果确实符合预期； 反向测试：当前置条件或输入不符合要求时（如：边界情况，非法输入），代码能优雅地进行处理，可以检查系统的容错能力和可靠性； 异常测试：代码在应该抛出异常的地方正确地抛出了异常。 我还会告诉你，每个单测都遵循 3As 模式： Arrange：准备数据； Act：执行待测函数； Assert：断言结果。 最后，别人闭口不提的，我也会告诉你： 测试套件（关键字 describe）是一组相关测试的集合，这组测试可以是验证一个函数，也可以是验证一组密切相关的函数的行为； 测试套件和测试用例的名称都需要简洁明了，且测试用例的名称要清楚表达测试目的和期望得到的结果，因为单测只是为了验证代码的正确行为，而我们的测试名称，描述、表达并记录了代码的行为，或者说原始需求； 当使用 3As 模式时，为了让代码看着舒服，不同的部分之间用空行隔开，另外每个单测里边的代码也需要保持简短，比如能用一行代码解决的事，也就不需要这个三部分了； 要是一个单测代码冗长复杂，它可能表达出了两种意思：一是测试的代码写的不好，二是待测函数的设计不行； 关注行为而非状态，避免为获取、设置状态的函数编写测试。从有业务价值的、有意思的行为开始编写。 在这个过程中对那些必要的状态进行设置和获取。 Emm…可以写代码了吗？ 首先，我通过分析需求，拆解出了若干任务列表，根据某个任务列表将迅速想到的用例记录在测试列表中，如下： mom 是回文 momu 不是回文 dad 是回文 空字符串不是回文 两个空格串不是回文 不传参，抛出参数非法异常 记住，测试列表需要不断的去完善它，因为你每前进一步，也许会想到新的问题。 好嘞，我们的第一个正向测试就出来了： 嘿，好家伙！这个测试么有通过。来看下 Jest 给我们反馈的信息： isPalindrome 函数没有实现或者还没有导入，那接下来我们将实现它并导入到测试文件中。 大家可以看到，我并没有一口气实现这个方法，而是使用初始测试驱动函数的接口设计，目的是为了让代码更具表现力和可读性。此时我们需要考虑： 函数名是否清晰描述代码功能 形参个数和名称是否满足需求 返回值类型是否正确 等… 让测试驱动设计，能够让我们将想到的问题提出来，帮助发现细节，然后在这个过程中梳理出代码的接口，还有可能找出需求的缺陷。 现在函数接口已经确定下来了，接下来的单测和实现，我将按照 TDD 的开发流程编写剩下所有的代码。剩下的代码就不贴出来了，需要的在 JestJsApp 自提，可以的话留个小星星哈！ Red - Green - Refactor Workflow： 编写测试用例; 运行测试，无法通过； 实现函数，测试用例通过； 优化代码，完成开发； 重复上述步骤。 ","date":"13130-01-130","objectID":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/:3:0","tags":["JavaScript","TDD","Jest"],"title":"4 年后，我再次入门 TDD","uri":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/"},{"categories":["TestDrivingJSApp"],"content":"0x04 代码覆盖率报告 代码覆盖率报告是很有价值的，但是也不能过度依赖它。 有价值的方面： 得到老板的夸奖； 能快速标识出哪些代码没有被测试覆盖到。 不过度依赖它，是因为它实际的数值并不特别重要，通常只有糟糕的数据令我们头疼，但良好的数据我们也要引起警觉。 比如，我某个文件的覆盖率是 98%，远远高于公司定的 80% 的标准，但是就是有一行代码没有被覆盖到，敢说这是合格的测试吗？此时，我们更需要关注的是检查哪行代码没有被测试覆盖，同时确保在修改代码时覆盖率数值没有降低。 如果你认为每一行代码都覆盖到了，就值得高歌一曲，我要告诉你代码都覆盖了也不一定是编写了充分的测试。我们可以从未覆盖的代码发现设计的缺陷，但我们不能从全部覆盖的代码上看到问题，所以我们还需要做代码和测试的审查来弥补。 ","date":"13130-01-130","objectID":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/:4:0","tags":["JavaScript","TDD","Jest"],"title":"4 年后，我再次入门 TDD","uri":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/"},{"categories":["TestDrivingJSApp"],"content":"0x05 总结 测试先行，有助于完善代码设计；小步迭代，有助于快速获取反馈重构代码。 最后，我们发现： 测试必须快速，以便我们快速获取反馈； 自动化校验，解放双手； 相互独立，测试结果互不依赖； 可重复执行n次且结果一致。 上边这四点说的就是著名的 F.A.I.R 原则！ ","date":"13130-01-130","objectID":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/:5:0","tags":["JavaScript","TDD","Jest"],"title":"4 年后，我再次入门 TDD","uri":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/"},{"categories":["TestDrivingJSApp"],"content":"0x06 参考 《JavaScript测试驱动开发》 Jest 官网 ","date":"13130-01-130","objectID":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/:6:0","tags":["JavaScript","TDD","Jest"],"title":"4 年后，我再次入门 TDD","uri":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/"},{"categories":null,"content":"易海门到底是谁？","date":"5050-10-50","objectID":"/about/","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"我是一名前端开发工程师，虽是科班出身，但在工作后越发的觉得基础的重要性。 所以我想专注于分享计算机基础，一边分享知识一边学习知识，提升自我，相互促进！ 现是 freeCodecamp 西安负责人，ByteWars 创始人之一，加入或创建这些社区，目的就是为了把经验（坑）分享出来，让后浪们少走弯路。 只有悄悄让自己拔尖，才能撑起成年人的不易。总之面包一定要有，肉也不能少。 ","date":"5050-10-50","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":["TestDrivingJSApp"],"content":"通过学习到达真的会写UnitTest的目的","date":"2020-05-20","objectID":"/2020/05/%E6%88%91%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99unittest%E5%90%97/","tags":["JavaScript","TDD","UnitTest"],"title":"我真的会写UnitTest吗？","uri":"/2020/05/%E6%88%91%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99unittest%E5%90%97/"},{"categories":["TestDrivingJSApp"],"content":"引子 大家好，我是以卖码为生的海门。上周和中仁聊到了 Test Double，可是对于那几个概念依然不是很清晰。于是对自己进行了灵魂拷问：我真的会写UnitTest吗？这其实包含两个意思：一个是会为业务代码写UnitTest，另一个是知道该怎么写UnitTest。最终，我被自己问住了。 ","date":"2020-05-20","objectID":"/2020/05/%E6%88%91%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99unittest%E5%90%97/:0:1","tags":["JavaScript","TDD","UnitTest"],"title":"我真的会写UnitTest吗？","uri":"/2020/05/%E6%88%91%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99unittest%E5%90%97/"},{"categories":["TestDrivingJSApp"],"content":"查资料 通过查看并回顾相关资料，我暂时了解了以下概念： 什么是测试？- 对代码功能的正确性验证 为什么要测试？- 解决各种“灵异”事件（神出鬼没的BUG），保证代码质量，更好的还原需求，最重要的是要测交付价值 不写无用的测试 有哪些测试？- 单元测试、集成测试、性能测试等 单元测试中的一个单元指的是什么？- 书面说明是最小可测试单元。我认为可以是一个函数或者一个类。期待大家的答案 单元测试有几种常用方法论？- TDD、BDD \u003c方法论不重要，重要的是使用方法论的人\u003e TDD：侧重点偏向开发，通过 Test Case 来提高代码的质量和设计 BDD：由外到内的开发方式，先定义业务成果，再实现这些业务成果，最后转化为验收标准 TDD 步骤（三角法） 伪代码 真代码 重构代码 TDD 思想 - 测试先行，小步迭代，重构和持续反馈 写好单元测试的原则 - F.I.R.S.T Fast - 测试必须快速 Independent - 测试独立，如测试结果不依赖环境或运行顺序 Repeatable - 可重复执行的纯函数 Self-validating - 自动化校验 Thorough and Timely - 尽量覆盖全部场景 如何覆盖全部场景？- 自补白盒测试 每个测试三段论 准备数据 - Given 执行待测函数 - When 断言结果 - Then Test Double 有哪些？- 针对这个，我还是有些概论比较模糊，期待大家的答案 Dummy Fake Stub Mock Spy ","date":"2020-05-20","objectID":"/2020/05/%E6%88%91%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99unittest%E5%90%97/:0:2","tags":["JavaScript","TDD","UnitTest"],"title":"我真的会写UnitTest吗？","uri":"/2020/05/%E6%88%91%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99unittest%E5%90%97/"},{"categories":["TestDrivingJSApp"],"content":"结语 为了写好一个单元测试，需要知道和理解的不仅仅是上边那些，比如还需要有识别代码中坏味道的能力，好的代码书写习惯，准确快速的盲打手法，快捷键的使用等等。接下来，我将边学习边分享的方式与大家一道，最终一同到达我真的会写 Unit Test 的目的。 ","date":"2020-05-20","objectID":"/2020/05/%E6%88%91%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99unittest%E5%90%97/:0:3","tags":["JavaScript","TDD","UnitTest"],"title":"我真的会写UnitTest吗？","uri":"/2020/05/%E6%88%91%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99unittest%E5%90%97/"}]